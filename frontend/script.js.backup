/**
 * Search Algorithms Visualizer - Frontend JavaScript
 * Refactored for better modularity and maintainability
 */

// ============================================================================
// CONFIGURATION & CONSTANTS
// ============================================================================

const CONFIG = {
    API_BASE_URL: 'http://localhost:5001/api',
    SVG_DIMENSIONS: {
        GRAPH_WIDTH: 600,
        GRAPH_HEIGHT: 500,
        NODE_RADIUS: 25,
        TREE_NODE_RADIUS: 20
    },
    COLORS: {
        START_NODE: '#28a745',
        GOAL_NODE: '#dc3545',
        VISITED_NODE: '#87ceeb',
        VISITED_STROKE: '#4682b4',
        PATH_NODE: '#ffd700',
        PATH_STROKE: '#ffa500',
        DEFAULT_NODE: 'white',
        DEFAULT_STROKE: '#667eea',
        EDGE: '#999'
    },
    ANIMATION: {
        PULSE_DURATION: 100,
        PATH_DELAY: 500
    }
};

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

class AppState {
    constructor() {
        this.examplesData = null;
        this.visualization = {
            mode: 'auto',
            currentStep: 0,
            totalSteps: 0,
            isPaused: false,
            result: null,
            animationDelay: 500,
            isRunning: false,
            context: null
        };
    }

    updateVisualization(updates) {
        this.visualization = { ...this.visualization, ...updates };
    }

    resetVisualization() {
        this.visualization = {
            ...this.visualization,
            currentStep: 0,
            isPaused: false,
            isRunning: false
        };
    }
}

const appState = new AppState();

// ============================================================================
// DOM ELEMENTS MANAGER
// ============================================================================

class DOMElements {
    constructor() {
        this.graphAlgorithmSelect = this.getElement('graph-algorithm');
        this.visualizationModeSelect = this.getElement('visualization-mode');
        this.animationSpeedSelect = this.getElement('animation-speed');
        this.exampleGraphSelect = this.getElement('example-graph');
        this.graphStartInput = this.getElement('graph-start');
        this.graphGoalInput = this.getElement('graph-goal');
        this.graphInput = this.getElement('graph-input');
        this.weightsInput = this.getElement('weights-input');
        this.heuristicInput = this.getElement('heuristic-input');
        this.startGraphButton = this.getElement('start-graph');
        this.generateTreeButton = this.getElement('generate-tree');
        this.clearGraphButton = this.getElement('clear-graph');
        this.treeDepthInput = this.getElement('tree-depth');
        this.graphStatsDiv = this.getElement('graph-stats');
        this.graphContainer = this.getElement('graph-container');
        this.treeContainer = this.getElement('state-space-tree-container');
    }

    getElement(id) {
        const element = document.getElementById(id);
        if (!element) {
            console.warn(`Element with id '${id}' not found`);
        }
        return element;
    }

    getInputValue(element) {
        return element ? element.value.trim() : '';
    }

    parseJSONInput(element, defaultValue = {}) {
        try {
            const value = this.getInputValue(element);
            return value ? JSON.parse(value) : defaultValue;
        } catch (e) {
            console.error('JSON parse error:', e);
            return defaultValue;
        }
    }
}

const dom = new DOMElements();

// ============================================================================
// API SERVICE
// ============================================================================

class APIService {
    static async fetchExamples() {
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/examples/graph`);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error('Error loading examples:', error);
            throw error;
        }
    }

    static async searchGraph(requestData) {
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/search/graph`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestData)
            });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error('Error running graph search:', error);
            throw error;
        }
    }

    static async generateTree(requestData) {
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/generate-tree`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestData)
            });
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return await response.json();
        } catch (error) {
            console.error('Error generating tree:', error);
            throw error;
        }
    }

    static async checkHealth() {
        try {
            const response = await fetch(`${CONFIG.API_BASE_URL}/health`);
            const data = await response.json();
            console.log('✅ Backend connection successful:', data);
            return true;
        } catch (error) {
            console.error('❌ Backend connection failed:', error);
            alert(`Warning: Cannot connect to backend server at ${CONFIG.API_BASE_URL}\n\nPlease make sure the Flask server is running on port 5001.`);
            return false;
        }
    }
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

const Utils = {
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },

    createSVGElement(tag, attributes = {}) {
        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
        Object.entries(attributes).forEach(([key, value]) => {
            element.setAttribute(key, value);
        });
        return element;
    },

    calculateCircularLayout(nodes, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.35;
        const positions = {};

        nodes.forEach((node, index) => {
            const angle = (2 * Math.PI * index) / nodes.length - Math.PI / 2;
            positions[node] = {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        });

        return positions;
    },

    getEdgeKey(node1, node2) {
        return [node1, node2].sort().join('-');
    }
};

// ============================================================================
// GRAPH VALIDATOR
// ============================================================================

class GraphValidator {
    static validateSearchInputs(start, goal, graph) {
        if (!start || !goal) {
            throw new Error('Please specify start and goal nodes');
        }
        if (Object.keys(graph).length === 0) {
            throw new Error('Please provide a graph structure');
        }
        return true;
    }

    static validateTreeInputs(start, graph) {
        if (!start) {
            throw new Error('Please specify a start node');
        }
        if (Object.keys(graph).length === 0) {
            throw new Error('Please provide a graph structure');
        }
        return true;
    }
}

// ============================================================================
// SVG RENDERER
// ============================================================================

class SVGRenderer {
    static createGraphSVG(width, height) {
        return Utils.createSVGElement('svg', {
            width: '100%',
            height: height,
            viewBox: `0 0 ${width} ${height}`
        });
    }

    static drawEdge(svg, pos1, pos2, edgeElements, edgeKey) {
        const line = Utils.createSVGElement('line', {
            x1: pos1.x, y1: pos1.y,
            x2: pos2.x, y2: pos2.y,
            stroke: CONFIG.COLORS.EDGE,
            'stroke-width': '2',
            opacity: '0.3'
        });
        svg.appendChild(line);
        edgeElements[edgeKey] = line;
        return line;
    }

    static drawNode(svg, node, pos, nodeType, nodeElements) {
        const colors = this.getNodeColors(nodeType);

        const circle = Utils.createSVGElement('circle', {
            cx: pos.x, cy: pos.y,
            r: CONFIG.SVG_DIMENSIONS.NODE_RADIUS,
            fill: colors.fill,
            stroke: colors.stroke,
            'stroke-width': '3',
            'data-node': node
        });
        circle.style.cursor = 'pointer';
        svg.appendChild(circle);
        nodeElements[node] = circle;

        const text = Utils.createSVGElement('text', {
            x: pos.x,
            y: pos.y + 5,
            'text-anchor': 'middle',
            'font-size': '16',
            'font-weight': 'bold',
            fill: nodeType !== 'default' ? 'white' : '#333',
            'pointer-events': 'none'
        });
        text.textContent = node;
        svg.appendChild(text);

        return { circle, text };
    }

    static getNodeColors(nodeType) {
        switch (nodeType) {
            case 'start':
                return { fill: CONFIG.COLORS.START_NODE, stroke: CONFIG.COLORS.START_NODE };
            case 'goal':
                return { fill: CONFIG.COLORS.GOAL_NODE, stroke: CONFIG.COLORS.GOAL_NODE };
            case 'visited':
                return { fill: CONFIG.COLORS.VISITED_NODE, stroke: CONFIG.COLORS.VISITED_STROKE };
            case 'path':
                return { fill: CONFIG.COLORS.PATH_NODE, stroke: CONFIG.COLORS.PATH_STROKE };
            default:
                return { fill: CONFIG.COLORS.DEFAULT_NODE, stroke: CONFIG.COLORS.DEFAULT_STROKE };
        }
    }

    static drawWeightLabel(svg, pos1, pos2, weight) {
        const midX = (pos1.x + pos2.x) / 2;
        const midY = (pos1.y + pos2.y) / 2;

        const circle = Utils.createSVGElement('circle', {
            cx: midX, cy: midY - 5,
            r: '12',
            fill: 'white',
            stroke: CONFIG.COLORS.EDGE,
            'stroke-width': '1'
        });
        svg.appendChild(circle);

        const text = Utils.createSVGElement('text', {
            x: midX,
            y: midY - 5,
            'text-anchor': 'middle',
            'font-size': '12',
            'font-weight': 'bold',
            fill: '#333'
        });
        text.textContent = weight;
        svg.appendChild(text);
    }

    static drawHeuristicLabel(svg, pos, heuristic) {
        const text = Utils.createSVGElement('text', {
            x: pos.x,
            y: pos.y + 40,
            'text-anchor': 'middle',
            'font-size': '11',
            fill: '#666'
        });
        text.textContent = `h=${heuristic}`;
        svg.appendChild(text);
    }

    static drawArrow(svg, pos1, pos2, color = '#ff6b00') {
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const angle = Math.atan2(dy, dx);
        const midX = (pos1.x + pos2.x) / 2;
        const midY = (pos1.y + pos2.y) / 2;
        const arrowSize = 15;

        const arrowX1 = midX - arrowSize * Math.cos(angle - Math.PI / 6);
        const arrowY1 = midY - arrowSize * Math.sin(angle - Math.PI / 6);
        const arrowX2 = midX - arrowSize * Math.cos(angle + Math.PI / 6);
        const arrowY2 = midY - arrowSize * Math.sin(angle + Math.PI / 6);

        const arrowPath = Utils.createSVGElement('path', {
            d: `M ${arrowX1} ${arrowY1} L ${midX} ${midY} L ${arrowX2} ${arrowY2}`,
            stroke: color,
            'stroke-width': '3',
            fill: 'none',
            'stroke-linecap': 'round'
        });
        svg.appendChild(arrowPath);
        return arrowPath;
    }
}

// ============================================================================
// UI COMPONENT BUILDERS
// ============================================================================

class UIBuilder {
    static createTitle(text) {
        const title = document.createElement('h3');
        title.textContent = text;
        title.style.textAlign = 'center';
        title.style.marginBottom = '15px';
        title.style.color = '#333';
        return title;
    }

    static createStatusDiv() {
        const statusDiv = document.createElement('div');
        statusDiv.id = 'traversal-status';
        statusDiv.style.marginTop = '15px';
        statusDiv.style.padding = '15px';
        statusDiv.style.background = '#e3f2fd';
        statusDiv.style.borderRadius = '8px';
        statusDiv.style.fontWeight = 'bold';
        statusDiv.style.fontSize = '1.1em';
        statusDiv.style.textAlign = 'center';
        statusDiv.innerHTML = '🚀 Starting algorithm...';
        return statusDiv;
    }

    static createManualControls() {
        const controlsDiv = document.createElement('div');
        controlsDiv.id = 'manual-controls';
        controlsDiv.style.marginTop = '15px';
        controlsDiv.style.padding = '15px';
        controlsDiv.style.background = '#fff3cd';
        controlsDiv.style.borderRadius = '8px';
        controlsDiv.style.textAlign = 'center';
        controlsDiv.innerHTML = `
            <h4 style="margin-top: 0; color: #856404;">Manual Mode Controls</h4>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 10px;">
                <button id="next-step-btn" class="btn btn-primary" style="padding: 10px 20px;">
                    ▶ Next Step
                </button>
                <button id="play-auto-btn" class="btn btn-success" style="padding: 10px 20px;">
                    ⏩ Play Auto
                </button>
                <button id="reset-viz-btn" class="btn btn-secondary" style="padding: 10px 20px;">
                    🔄 Reset
                </button>
            </div>
            <p style="margin-top: 10px; margin-bottom: 0; color: #856404; font-size: 0.9em;">
                Step <span id="current-step">0</span> of <span id="total-steps">0</span>
            </p>
        `;
        return controlsDiv;
    }

    static createLegend(items) {
        const legend = document.createElement('div');
        legend.style.marginTop = '20px';
        legend.style.padding = '15px';
        legend.style.background = '#f8f9fa';
        legend.style.borderRadius = '8px';

        let html = '<h4 style="margin-bottom: 10px;">Graph Legend</h4>';
        html += '<div style="display: flex; gap: 20px; flex-wrap: wrap;">';

        items.forEach(item => {
            html += `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: ${item.width || '20px'}; height: ${item.height || '20px'}; 
                                background: ${item.color}; border-radius: ${item.borderRadius || '50%'}; 
                                border: 2px solid ${item.borderColor || item.color};"></div>
                    <span>${item.label}</span>
                </div>
            `;
        });

        html += '</div>';
        legend.innerHTML = html;
        return legend;
    }

    static displayResults(result) {
        const algorithm = dom.graphAlgorithmSelect.value.toUpperCase();
        const pathStr = result.path ? result.path.join(' → ') : 'No path found';
        const visitedStr = result.visited ? result.visited.join(', ') : 'None';

        dom.graphStatsDiv.innerHTML = `
            <h3>Search Results</h3>
            <p><strong>Algorithm:</strong> ${result.algorithm || algorithm}</p>
            <p><strong>Success:</strong> ${result.success ? '✅ Yes' : '❌ No'}</p>
            <p><strong>Path:</strong> ${pathStr}</p>
            <p><strong>Path Length:</strong> ${result.path ? result.path.length : 0} nodes</p>
            <p><strong>Nodes Visited:</strong> ${result.visited ? result.visited.length : 0}</p>
            <p><strong>Visited Order:</strong> ${visitedStr}</p>
            ${result.cost !== undefined ? `<p><strong>Total Cost:</strong> ${result.cost}</p>` : ''}
            ${result.distance !== undefined ? `<p><strong>Distance:</strong> ${result.distance}</p>` : ''}
        `;
    }
}

// ============================================================================
// GRAPH BUILDER
// ============================================================================

class GraphBuilder {
    constructor(container, graph, start, goal) {
        this.container = container;
        this.graph = graph;
        this.start = start;
        this.goal = goal;
        this.nodes = Object.keys(graph);
        this.nodePositions = null;
        this.nodeElements = {};
        this.edgeElements = {};
        this.svg = null;
    }

    build() {
        const { GRAPH_WIDTH, GRAPH_HEIGHT } = CONFIG.SVG_DIMENSIONS;

        // Create SVG
        this.svg = SVGRenderer.createGraphSVG(GRAPH_WIDTH, GRAPH_HEIGHT);
        this.svg.style.background = 'white';
        this.svg.style.border = '2px solid #ddd';
        this.svg.style.borderRadius = '8px';

        // Calculate positions
        this.nodePositions = Utils.calculateCircularLayout(
            this.nodes, GRAPH_WIDTH, GRAPH_HEIGHT
        );

        // Draw edges
        this.drawEdges();

        // Draw nodes
        this.drawNodes();

        this.container.appendChild(this.svg);

        return {
            svg: this.svg,
            nodeElements: this.nodeElements,
            edgeElements: this.edgeElements,
            nodePositions: this.nodePositions
        };
    }

    drawEdges() {
        const edges = new Set();
        const weights = dom.parseJSONInput(dom.weightsInput);

        this.nodes.forEach(node => {
            this.graph[node].forEach(neighbor => {
                const edgeKey = Utils.getEdgeKey(node, neighbor);
                if (!edges.has(edgeKey)) {
                    edges.add(edgeKey);
                    const pos1 = this.nodePositions[node];
                    const pos2 = this.nodePositions[neighbor];

                    SVGRenderer.drawEdge(this.svg, pos1, pos2, this.edgeElements, edgeKey);

                    // Add weight label if available
                    const weight = weights[`${node}-${neighbor}`] || weights[`${neighbor}-${node}`];
                    if (weight !== undefined) {
                        SVGRenderer.drawWeightLabel(this.svg, pos1, pos2, weight);
                    }
                }
            });
        });
    }

    drawNodes() {
        const heuristics = dom.parseJSONInput(dom.heuristicInput);

        this.nodes.forEach(node => {
            const pos = this.nodePositions[node];
            let nodeType = 'default';

            if (node === this.start) nodeType = 'start';
            else if (node === this.goal) nodeType = 'goal';

            SVGRenderer.drawNode(this.svg, node, pos, nodeType, this.nodeElements);

            // Add heuristic label if available
            if (heuristics[node] !== undefined) {
                SVGRenderer.drawHeuristicLabel(this.svg, pos, heuristics[node]);
            }
        });
    }
}

// ============================================================================
// TREE VISUALIZER
// ============================================================================

class TreeVisualizer {
    constructor(container, result, start, goal) {
        this.container = container;
        this.result = result;
        this.start = start;
        this.goal = goal;
        this.svg = null;
        this.nodePositions = {};
        this.nodeElements = {};
        this.edgeElements = {};
        this.nodesAdded = new Set();
        this.edgesAdded = new Set();
    }

    initialize() {
        const children = {};
        this.result.tree_edges.forEach(([parent, child]) => {
            if (!children[parent]) children[parent] = [];
            children[parent].push(child);
        });

        const levelNodes = {};
        let maxLevel = 0;
        const queue = [[this.start, 0]];
        const visited = new Set();

        while (queue.length > 0) {
            const [node, level] = queue.shift();
            if (visited.has(node)) continue;
            visited.add(node);

            if (!levelNodes[level]) levelNodes[level] = [];
            levelNodes[level].push(node);
            maxLevel = Math.max(maxLevel, level);
            this.nodePositions[node] = { level };

            if (children[node]) {
                children[node].forEach(child => {
                    if (!visited.has(child)) {
                        queue.push([child, level + 1]);
                    }
                });
            }
        }

        const width = Math.max(800, Object.keys(this.nodePositions).length * 80);
        const height = (maxLevel + 1) * 120 + 100;
        const levelHeight = height / (maxLevel + 2);

        Object.keys(levelNodes).forEach(level => {
            const nodesInLevel = levelNodes[level];
            const spacing = width / (nodesInLevel.length + 1);
            nodesInLevel.forEach((node, index) => {
                this.nodePositions[node].x = spacing * (index + 1);
                this.nodePositions[node].y = levelHeight * (parseInt(level) + 1);
            });
        });

        this.svg = Utils.createSVGElement('svg', {
            class: 'tree-svg',
            width: '100%',
            height: height,
            viewBox: `0 0 ${width} ${height}`
        });

        this.container.appendChild(this.svg);

        return {
            svg: this.svg,
            nodePositions: this.nodePositions,
            children,
            treeEdges: this.result.tree_edges,
            nodesAdded: this.nodesAdded,
            edgesAdded: this.edgesAdded,
            nodeElements: this.nodeElements,
            edgeElements: this.edgeElements,
            start: this.start,
            goal: this.goal
        };
    }

    async updateNode(currentNode) {
        if (!this.nodePositions[currentNode]) return;

        // Add edges
        this.result.tree_edges.forEach(([parent, child]) => {
            if (child === currentNode && this.nodesAdded.has(parent) &&
                !this.edgesAdded.has(`${parent}-${child}`)) {
                this.drawTreeEdge(parent, child);
            }
        });

        // Add node
        if (!this.nodesAdded.has(currentNode)) {
            this.drawTreeNode(currentNode);
        }
    }

    drawTreeEdge(parent, child) {
        const pos1 = this.nodePositions[parent];
        const pos2 = this.nodePositions[child];

        const line = Utils.createSVGElement('line', {
            x1: pos1.x, y1: pos1.y,
            x2: pos2.x, y2: pos2.y,
            class: 'tree-edge',
            opacity: '0'
        });
        this.svg.appendChild(line);
        setTimeout(() => line.setAttribute('opacity', '1'), 50);

        // Draw arrow
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const angle = Math.atan2(dy, dx);
        const arrowSize = 8;
        const arrowX = pos2.x - 25 * Math.cos(angle);
        const arrowY = pos2.y - 25 * Math.sin(angle);

        const points = [
            [arrowX, arrowY],
            [arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
             arrowY - arrowSize * Math.sin(angle - Math.PI / 6)],
            [arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
             arrowY - arrowSize * Math.sin(angle + Math.PI / 6)]
        ];

        const arrow = Utils.createSVGElement('polygon', {
            points: points.map(p => p.join(',')).join(' '),
            fill: '#999',
            opacity: '0'
        });
        this.svg.appendChild(arrow);
        setTimeout(() => arrow.setAttribute('opacity', '1'), 50);

        this.edgesAdded.add(`${parent}-${child}`);
        this.edgeElements[`${parent}-${child}`] = { line, arrow };
    }

    drawTreeNode(node) {
        const pos = this.nodePositions[node];
        let nodeType = 'visited';

        if (node === this.start) nodeType = 'start';
        else if (node === this.goal) nodeType = 'goal';

        const colors = SVGRenderer.getNodeColors(nodeType);

        const circle = Utils.createSVGElement('circle', {
            cx: pos.x, cy: pos.y,
            r: '0',
            fill: colors.fill,
            stroke: colors.stroke,
            'stroke-width': '3',
            class: 'tree-node'
        });
        this.svg.appendChild(circle);

        // Animate appearance
        let currentR = 0;
        const targetR = CONFIG.SVG_DIMENSIONS.TREE_NODE_RADIUS;
        const animateNode = () => {
            if (currentR < targetR) {
                currentR += 2;
                circle.setAttribute('r', currentR);
                requestAnimationFrame(animateNode);
            }
        };
        animateNode();

        const text = Utils.createSVGElement('text', {
            x: pos.x, y: pos.y + 5,
            class: 'tree-label',
            fill: (node === this.start || node === this.goal) ? 'white' : '#333',
            opacity: '0'
        });
        text.textContent = node;
        this.svg.appendChild(text);
        setTimeout(() => text.setAttribute('opacity', '1'), 100);

        // Level indicator
        const levelText = Utils.createSVGElement('text', {
            x: pos.x, y: pos.y + 35,
            'font-size': '10',
            'text-anchor': 'middle',
            fill: '#666',
            opacity: '0'
        });
        levelText.textContent = `L${pos.level}`;
        this.svg.appendChild(levelText);
        setTimeout(() => levelText.setAttribute('opacity', '1'), 100);

        this.nodesAdded.add(node);
        this.nodeElements[node] = circle;
    }

    highlightPath(path) {
        const pathSet = new Set(path);

        Object.keys(this.nodeElements).forEach(node => {
            if (pathSet.has(node)) {
                this.nodeElements[node].setAttribute('fill', CONFIG.COLORS.PATH_NODE);
                this.nodeElements[node].setAttribute('stroke', CONFIG.COLORS.PATH_STROKE);
                this.nodeElements[node].setAttribute('stroke-width', '4');
            }
        });

        Object.keys(this.edgeElements).forEach(edgeKey => {
            const [parent, child] = edgeKey.split('-');
            if (pathSet.has(parent) && pathSet.has(child)) {
                this.edgeElements[edgeKey].line.setAttribute('class', 'tree-edge path-edge');
                this.edgeElements[edgeKey].arrow.setAttribute('fill', CONFIG.COLORS.PATH_STROKE);
            }
        });
    }
}

// ============================================================================
// ANIMATION CONTROLLER
// ============================================================================

class AnimationController {
    constructor(context) {
        this.ctx = context;
    }

    async animateVisitNode(node, index) {
        const { nodeElements, statusDiv, treeViz, result, start, goal } = this.ctx;
        const nodeEl = nodeElements[node];

        statusDiv.innerHTML = `📊 Algorithm: ${result.algorithm}<br>👀 Visiting node: <strong>${node}</strong> (${index + 1}/${result.visited.length})`;

        if (nodeEl && node !== start && node !== goal) {
            nodeEl.setAttribute('fill', CONFIG.COLORS.VISITED_NODE);
            nodeEl.setAttribute('stroke', CONFIG.COLORS.VISITED_STROKE);
            nodeEl.setAttribute('stroke-width', '3');

            // Pulse animation
            nodeEl.setAttribute('r', CONFIG.SVG_DIMENSIONS.NODE_RADIUS + 5);
            await Utils.sleep(CONFIG.ANIMATION.PULSE_DURATION);
            nodeEl.setAttribute('r', CONFIG.SVG_DIMENSIONS.NODE_RADIUS);
        }

        await treeViz.updateNode(node);
    }

    async animatePathNode(pathIndex) {
        const { nodeElements, edgeElements, nodePositions, statusDiv, treeViz, result, svg, start, goal } = this.ctx;

        if (!result.path || pathIndex >= result.path.length) return;

        const node = result.path[pathIndex];
        const nodeEl = nodeElements[node];

        if (pathIndex === 0) {
            statusDiv.innerHTML = `✅ Path found! Highlighting the solution path...`;
            await Utils.sleep(300);
        }

        if (nodeEl && node !== start && node !== goal) {
            nodeEl.setAttribute('fill', CONFIG.COLORS.PATH_NODE);
            nodeEl.setAttribute('stroke', CONFIG.COLORS.PATH_STROKE);
            nodeEl.setAttribute('stroke-width', '4');

            // Pulse animation
            nodeEl.setAttribute('r', CONFIG.SVG_DIMENSIONS.NODE_RADIUS + 7);
            await Utils.sleep(150);
            nodeEl.setAttribute('r', CONFIG.SVG_DIMENSIONS.NODE_RADIUS);
        }

        // Highlight edge to next node
        if (pathIndex < result.path.length - 1) {
            const nextNode = result.path[pathIndex + 1];
            const edgeKey = Utils.getEdgeKey(node, nextNode);
            const edgeEl = edgeElements[edgeKey];

            if (edgeEl) {
                edgeEl.setAttribute('stroke', CONFIG.COLORS.PATH_STROKE);
                edgeEl.setAttribute('stroke-width', '4');
                edgeEl.setAttribute('opacity', '1');

                const pos1 = nodePositions[node];
                const pos2 = nodePositions[nextNode];
                SVGRenderer.drawArrow(svg, pos1, pos2);
            }

            statusDiv.innerHTML = `🎯 Path: ${result.path.slice(0, pathIndex + 2).join(' → ')}`;
        }

        treeViz.highlightPath(result.path);

        if (pathIndex === result.path.length - 1) {
            this.displayFinalResults();
        }
    }

    displayFinalResults() {
        const { statusDiv, result, graph } = this.ctx;

        statusDiv.innerHTML = `✅ <strong>Success!</strong> Path found: ${result.path.join(' → ')}`;
        statusDiv.style.background = '#c8e6c9';

        UIBuilder.displayResults(result);
        this.addLegendAndInfo(graph, result);
    }

    addLegendAndInfo(graph, result) {
        const legendItems = [
            { color: CONFIG.COLORS.START_NODE, borderColor: CONFIG.COLORS.START_NODE, label: 'Start Node' },
            { color: CONFIG.COLORS.GOAL_NODE, borderColor: CONFIG.COLORS.GOAL_NODE, label: 'Goal Node' },
            { color: CONFIG.COLORS.VISITED_NODE, borderColor: CONFIG.COLORS.VISITED_STROKE, label: 'Visited Node' },
            { color: CONFIG.COLORS.PATH_NODE, borderColor: CONFIG.COLORS.PATH_STROKE, label: 'Path Node' },
            { color: CONFIG.COLORS.PATH_STROKE, borderColor: CONFIG.COLORS.PATH_STROKE,
              label: 'Path Edge', width: '30px', height: '3px', borderRadius: '0' }
        ];

        dom.graphContainer.appendChild(UIBuilder.createLegend(legendItems));

        // Add adjacency list
        const path = new Set(result.path || []);
        const nodes = Object.keys(graph);
        const adjList = document.createElement('div');
        adjList.style.marginTop = '20px';
        adjList.style.padding = '15px';
        adjList.style.background = '#f8f9fa';
        adjList.style.borderRadius = '8px';
        adjList.innerHTML = '<h4>Adjacency List</h4><ul style="columns: 2; margin-top: 10px;">';

        nodes.forEach(node => {
            const className = path.has(node) ? 'style="color: #ffa500; font-weight: bold;"' : '';
            adjList.innerHTML += `<li ${className}><strong>${node}:</strong> [${graph[node].join(', ')}]</li>`;
        });

        adjList.innerHTML += '</ul>';
        dom.graphContainer.appendChild(adjList);

        // Add tree legend
        const treeLegend = document.createElement('div');
        treeLegend.className = 'tree-info';
        treeLegend.style.marginTop = '15px';
        treeLegend.innerHTML = `
            <h4>State Space Tree Legend</h4>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                <strong>Real-time Exploration:</strong> Nodes appear as they are discovered during traversal.
            </p>
        `;
        dom.treeContainer.appendChild(treeLegend);
    }
}

// ============================================================================
// VISUALIZATION MANAGER
// ============================================================================

class VisualizationManager {
    static async visualize(graph, result) {
        appState.updateVisualization({
            mode: dom.visualizationModeSelect.value,
            animationDelay: parseInt(dom.animationSpeedSelect.value),
            result: result,
            currentStep: 0,
            isRunning: true
        });

        const start = dom.getInputValue(dom.graphStartInput);
        const goal = dom.getInputValue(dom.graphGoalInput);

        // Clear containers
        dom.graphContainer.innerHTML = '';
        dom.treeContainer.innerHTML = '';

        // Add titles
        dom.graphContainer.appendChild(UIBuilder.createTitle('📊 Graph Visualization'));
        dom.treeContainer.appendChild(UIBuilder.createTitle('🌳 State Space Tree'));

        // Build graph
        const graphBuilder = new GraphBuilder(dom.graphContainer, graph, start, goal);
        const graphElements = graphBuilder.build();

        // Add status div
        const statusDiv = UIBuilder.createStatusDiv();
        dom.graphContainer.appendChild(statusDiv);

        // Add manual controls if needed
        if (appState.visualization.mode === 'manual') {
            const controls = UIBuilder.createManualControls();
            dom.graphContainer.appendChild(controls);
        }

        // Initialize tree
        const treeViz = new TreeVisualizer(dom.treeContainer, result, start, goal);
        const treeElements = treeViz.initialize();

        // Store context
        const context = {
            ...graphElements,
            statusDiv,
            treeViz,
            result,
            graph,
            start,
            goal
        };

        appState.updateVisualization({ context });

        // Calculate total steps
        const visitedSteps = result.visited ? result.visited.length : 0;
        const pathSteps = result.path ? result.path.length : 0;
        appState.updateVisualization({ totalSteps: visitedSteps + pathSteps });

        if (appState.visualization.mode === 'manual') {
            this.setupManualMode();
        } else {
            await this.runAutoMode();
        }
    }

    static setupManualMode() {
        document.getElementById('total-steps').textContent = appState.visualization.totalSteps;
        document.getElementById('current-step').textContent = '0';

        document.getElementById('next-step-btn').addEventListener('click', () => this.executeNextStep());
        document.getElementById('play-auto-btn').addEventListener('click', () => this.playAutoFromCurrent());
        document.getElementById('reset-viz-btn').addEventListener('click', () => {
            appState.resetVisualization();
            SearchController.runSearch();
        });
    }

    static async executeNextStep() {
        const ctx = appState.visualization.context;
        const result = ctx.result;
        const visitedSteps = result.visited ? result.visited.length : 0;
        const controller = new AnimationController(ctx);

        if (appState.visualization.currentStep < visitedSteps) {
            const i = appState.visualization.currentStep;
            await controller.animateVisitNode(result.visited[i], i);
        } else if (appState.visualization.currentStep < appState.visualization.totalSteps) {
            const pathIndex = appState.visualization.currentStep - visitedSteps;
            await controller.animatePathNode(pathIndex);
        } else {
            ctx.statusDiv.innerHTML = `✅ <strong>Visualization Complete!</strong>`;
            ctx.statusDiv.style.background = '#c8e6c9';
            return;
        }

        appState.visualization.currentStep++;
        document.getElementById('current-step').textContent = appState.visualization.currentStep;
    }

    static async playAutoFromCurrent() {
        const playBtn = document.getElementById('play-auto-btn');
        const nextBtn = document.getElementById('next-step-btn');

        playBtn.disabled = true;
        nextBtn.disabled = true;
        playBtn.textContent = '⏸ Playing...';

        while (appState.visualization.currentStep < appState.visualization.totalSteps) {
            await this.executeNextStep();
            await Utils.sleep(appState.visualization.animationDelay);
        }

        playBtn.textContent = '✅ Complete';
        nextBtn.disabled = false;
    }

    static async runAutoMode() {
        const ctx = appState.visualization.context;
        const result = ctx.result;
        const controller = new AnimationController(ctx);

        // Animate visited nodes
        if (result.visited && result.visited.length > 0) {
            ctx.statusDiv.innerHTML = `📊 Algorithm: ${result.algorithm}<br>👀 Exploring nodes...`;

            for (let i = 0; i < result.visited.length; i++) {
                await controller.animateVisitNode(result.visited[i], i);
                await Utils.sleep(appState.visualization.animationDelay);
            }
        }

        // Animate path
        if (result.path && result.path.length > 1) {
            ctx.statusDiv.innerHTML = `✅ Path found! Highlighting the solution path...`;
            await Utils.sleep(CONFIG.ANIMATION.PATH_DELAY);

            for (let i = 0; i < result.path.length; i++) {
                await controller.animatePathNode(i);
                await Utils.sleep(appState.visualization.animationDelay);
            }
        } else if (!result.success) {
            ctx.statusDiv.innerHTML = `❌ No path found from ${ctx.start} to ${ctx.goal}`;
            ctx.statusDiv.style.background = '#ffcdd2';
        }

        UIBuilder.displayResults(result);
        controller.addLegendAndInfo(ctx.graph, result);
    }
}

// ============================================================================
// SEARCH CONTROLLER
// ============================================================================

class SearchController {
    static async runSearch() {
        try {
            const start = dom.getInputValue(dom.graphStartInput);
            const goal = dom.getInputValue(dom.graphGoalInput);
            const graph = dom.parseJSONInput(dom.graphInput);
            const weights = dom.parseJSONInput(dom.weightsInput);
            const heuristic = dom.parseJSONInput(dom.heuristicInput);

            GraphValidator.validateSearchInputs(start, goal, graph);

            const requestData = {
                algorithm: dom.graphAlgorithmSelect.value,
                graph,
                start,
                goal,
                weights,
                heuristic
            };

            dom.startGraphButton.disabled = true;
            dom.startGraphButton.textContent = 'Searching...';

            const result = await APIService.searchGraph(requestData);
            console.log('Graph search result:', result);

            await VisualizationManager.visualize(graph, result);

        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            dom.startGraphButton.disabled = false;
            dom.startGraphButton.textContent = 'Start Search';
        }
    }

    static async generateTree() {
        try {
            const start = dom.getInputValue(dom.graphStartInput);
            const graph = dom.parseJSONInput(dom.graphInput);

            GraphValidator.validateTreeInputs(start, graph);

            const maxDepth = parseInt(dom.treeDepthInput.value) || 4;
            const requestData = { graph, start, max_depth: maxDepth };

            dom.generateTreeButton.disabled = true;
            dom.generateTreeButton.textContent = 'Generating...';

            const treeData = await APIService.generateTree(requestData);
            console.log('Tree data received:', treeData);

            if (!treeData.tree_edges || treeData.tree_edges.length === 0) {
                throw new Error('No tree edges generated');
            }

            await TreeController.visualizeCompleteTree(graph, treeData, start);

        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            dom.generateTreeButton.disabled = false;
            dom.generateTreeButton.textContent = 'Generate Complete State Space Tree';
        }
    }

    static clearResults() {
        dom.graphStatsDiv.innerHTML = '';
        dom.graphContainer.innerHTML = '';
        dom.treeContainer.innerHTML = '';
    }
}

// ============================================================================
// TREE CONTROLLER (for complete state space tree)
// ============================================================================

class TreeController {
    static async visualizeCompleteTree(graph, treeData, start) {
        const goal = dom.getInputValue(dom.graphGoalInput);

        dom.graphContainer.innerHTML = '';
        dom.treeContainer.innerHTML = '';

        // Draw graph structure
        dom.graphContainer.appendChild(UIBuilder.createTitle('📊 Graph Structure'));
        const graphBuilder = new GraphBuilder(dom.graphContainer, graph, start, goal);
        graphBuilder.build();

        // Add graph info
        const nodes = Object.keys(graph);
        const graphInfo = document.createElement('div');
        graphInfo.style.marginTop = '15px';
        graphInfo.style.padding = '15px';
        graphInfo.style.background = '#f8f9fa';
        graphInfo.style.borderRadius = '8px';
        graphInfo.innerHTML = `
            <h4>Graph Information</h4>
            <p><strong>Total Nodes:</strong> ${nodes.length}</p>
            <p><strong>Start Node:</strong> <span style="color: ${CONFIG.COLORS.START_NODE}; font-weight: bold;">${start}</span></p>
            ${goal ? `<p><strong>Goal Node:</strong> <span style="color: ${CONFIG.COLORS.GOAL_NODE}; font-weight: bold;">${goal}</span></p>` : ''}
        `;
        dom.graphContainer.appendChild(graphInfo);

        // Draw complete state space tree
        dom.treeContainer.appendChild(UIBuilder.createTitle('🌳 Complete State Space Tree'));

        const treeInfo = document.createElement('div');
        treeInfo.style.padding = '15px';
        treeInfo.style.background = '#e3f2fd';
        treeInfo.style.borderRadius = '8px';
        treeInfo.style.marginBottom = '15px';
        treeInfo.innerHTML = `
            <p><strong>📊 Tree Statistics:</strong></p>
            <p>• Total Edges: ${treeData.tree_edges.length}</p>
            <p>• Max Depth: ${treeData.max_depth}</p>
            <p>• Start Node: <strong>${start}</strong></p>
            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                This shows all possible paths from the start node up to depth ${treeData.max_depth}.
                Nodes can appear multiple times in different branches.
            </p>
        `;
        dom.treeContainer.appendChild(treeInfo);

        // Build and display tree (simplified version)
        this.buildCompleteTree(treeData, start, goal);

        // Display stats
        dom.graphStatsDiv.innerHTML = `
            <h3>Complete State Space Tree Generated</h3>
            <p><strong>Start Node:</strong> ${start}</p>
            <p><strong>Total Exploration Edges:</strong> ${treeData.tree_edges.length}</p>
            <p><strong>Maximum Depth:</strong> ${treeData.max_depth} levels</p>
            <p style="margin-top: 10px; color: #666;">
                💡 <strong>Tip:</strong> Now you can run a search algorithm to see how it explores this space!
            </p>
        `;
    }

    static buildCompleteTree(treeData, start, goal) {
        // Build unique node instances for tree branches
        const nodeInstances = [];
        const levelNodes = {};
        const rootKey = `${start}_root`;
        const treeNodePositions = {};
        const instanceChildren = {};

        treeNodePositions[rootKey] = { level: 0, originalNode: start, parentKey: null };
        nodeInstances.push(rootKey);
        levelNodes[0] = [rootKey];

        let currentLevel = 0;
        const levelQueues = { 0: [rootKey] };
        let maxLevel = 0;

        while (currentLevel <= treeData.max_depth && levelQueues[currentLevel]?.length > 0) {
            const parentsAtLevel = levelQueues[currentLevel];

            for (const parentKey of parentsAtLevel) {
                const parentNode = treeNodePositions[parentKey].originalNode;
                const childEdges = treeData.tree_edges.filter(([p, c]) => p === parentNode);

                childEdges.forEach(([parent, child]) => {
                    const childKey = `${child}_${parentKey}_${Math.random().toString(36).substr(2, 9)}`;
                    const childLevel = currentLevel + 1;

                    treeNodePositions[childKey] = {
                        level: childLevel,
                        originalNode: child,
                        parentKey: parentKey
                    };
                    nodeInstances.push(childKey);

                    if (!levelNodes[childLevel]) levelNodes[childLevel] = [];
                    levelNodes[childLevel].push(childKey);
                    maxLevel = Math.max(maxLevel, childLevel);

                    if (!instanceChildren[parentKey]) instanceChildren[parentKey] = [];
                    instanceChildren[parentKey].push(childKey);

                    if (childLevel < treeData.max_depth) {
                        if (!levelQueues[childLevel]) levelQueues[childLevel] = [];
                        levelQueues[childLevel].push(childKey);
                    }
                });
            }
            currentLevel++;
        }

        // Calculate positions
        const treeWidth = Math.max(1000, nodeInstances.length * 60);
        const treeHeight = (maxLevel + 1) * 120 + 100;
        const levelHeight = treeHeight / (maxLevel + 2);

        Object.keys(levelNodes).forEach(level => {
            const nodesInLevel = levelNodes[level];
            const spacing = treeWidth / (nodesInLevel.length + 1);
            nodesInLevel.forEach((nodeKey, index) => {
                treeNodePositions[nodeKey].x = spacing * (index + 1);
                treeNodePositions[nodeKey].y = levelHeight * (parseInt(level) + 1);
            });
        });

        // Create and draw SVG
        const treeSvg = Utils.createSVGElement('svg', {
            class: 'tree-svg',
            width: '100%',
            height: Math.min(treeHeight, 800),
            viewBox: `0 0 ${treeWidth} ${treeHeight}`
        });
        treeSvg.style.border = '2px solid #ddd';
        treeSvg.style.borderRadius = '8px';
        treeSvg.style.background = 'white';

        // Draw edges
        Object.keys(instanceChildren).forEach(parentKey => {
            instanceChildren[parentKey].forEach(childKey => {
                if (treeNodePositions[parentKey] && treeNodePositions[childKey]) {
                    const pos1 = treeNodePositions[parentKey];
                    const pos2 = treeNodePositions[childKey];

                    const line = Utils.createSVGElement('line', {
                        x1: pos1.x, y1: pos1.y,
                        x2: pos2.x, y2: pos2.y,
                        stroke: CONFIG.COLORS.EDGE,
                        'stroke-width': '2',
                        opacity: '0.6'
                    });
                    treeSvg.appendChild(line);

                    // Add arrow
                    const dx = pos2.x - pos1.x;
                    const dy = pos2.y - pos1.y;
                    const angle = Math.atan2(dy, dx);
                    const arrowSize = 8;
                    const arrowX = pos2.x - 22 * Math.cos(angle);
                    const arrowY = pos2.y - 22 * Math.sin(angle);

                    const points = [
                        [arrowX, arrowY],
                        [arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
                         arrowY - arrowSize * Math.sin(angle - Math.PI / 6)],
                        [arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
                         arrowY - arrowSize * Math.sin(angle + Math.PI / 6)]
                    ];

                    const arrow = Utils.createSVGElement('polygon', {
                        points: points.map(p => p.join(',')).join(' '),
                        fill: CONFIG.COLORS.EDGE,
                        opacity: '0.6'
                    });
                    treeSvg.appendChild(arrow);
                }
            });
        });

        // Draw nodes
        nodeInstances.forEach(nodeKey => {
            if (treeNodePositions[nodeKey]) {
                const pos = treeNodePositions[nodeKey];
                const originalNode = treeNodePositions[nodeKey].originalNode;

                let fillColor = CONFIG.COLORS.DEFAULT_NODE;
                let strokeColor = CONFIG.COLORS.DEFAULT_STROKE;

                if (originalNode === start && pos.level === 0) {
                    fillColor = CONFIG.COLORS.START_NODE;
                    strokeColor = CONFIG.COLORS.START_NODE;
                } else if (goal && originalNode === goal) {
                    fillColor = CONFIG.COLORS.GOAL_NODE;
                    strokeColor = CONFIG.COLORS.GOAL_NODE;
                }

                const circle = Utils.createSVGElement('circle', {
                    cx: pos.x, cy: pos.y,
                    r: CONFIG.SVG_DIMENSIONS.TREE_NODE_RADIUS,
                    fill: fillColor,
                    stroke: strokeColor,
                    'stroke-width': '3'
                });
                treeSvg.appendChild(circle);

                const text = Utils.createSVGElement('text', {
                    x: pos.x, y: pos.y + 5,
                    'text-anchor': 'middle',
                    'font-size': '14',
                    'font-weight': 'bold',
                    fill: (fillColor !== CONFIG.COLORS.DEFAULT_NODE) ? 'white' : '#333'
                });
                text.textContent = originalNode;
                treeSvg.appendChild(text);

                const levelText = Utils.createSVGElement('text', {
                    x: pos.x, y: pos.y + 35,
                    'font-size': '10',
                    'text-anchor': 'middle',
                    fill: '#666'
                });
                levelText.textContent = `L${pos.level}`;
                treeSvg.appendChild(levelText);
            }
        });

        dom.treeContainer.appendChild(treeSvg);
    }
}

// ============================================================================
// EXAMPLE LOADER
// ============================================================================

class ExampleLoader {
    static async load() {
        try {
            appState.examplesData = await APIService.fetchExamples();
            console.log('Loaded graph examples:', appState.examplesData);
        } catch (error) {
            console.error('Failed to load examples:', error);
        }
    }

    static loadSelected() {
        const exampleName = dom.exampleGraphSelect.value;
        if (!exampleName || !appState.examplesData) return;

        const example = appState.examplesData[exampleName];
        if (!example) return;

        dom.graphInput.value = JSON.stringify(example.graph, null, 2);
        dom.weightsInput.value = JSON.stringify(example.weights, null, 2);
        dom.heuristicInput.value = JSON.stringify(example.heuristic, null, 2);
        dom.graphStartInput.value = example.start;
        dom.graphGoalInput.value = example.goal;

        console.log('Loaded example:', exampleName);
    }
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

class EventHandlers {
    static attachAll() {
        dom.exampleGraphSelect.addEventListener('change', () => ExampleLoader.loadSelected());
        dom.startGraphButton.addEventListener('click', () => SearchController.runSearch());
        dom.generateTreeButton.addEventListener('click', () => SearchController.generateTree());
        dom.clearGraphButton.addEventListener('click', () => SearchController.clearResults());
    }
}

// ============================================================================
// APPLICATION INITIALIZATION
// ============================================================================

class App {
    static async initialize() {
        console.log('🚀 Search Algorithms Visualizer initialized');
        console.log('📡 Backend API:', CONFIG.API_BASE_URL);

        await ExampleLoader.load();
        EventHandlers.attachAll();

        // Test backend connection
        setTimeout(() => APIService.checkHealth(), 500);
    }
}

// Initialize application when DOM is ready
document.addEventListener('DOMContentLoaded', () => App.initialize());

